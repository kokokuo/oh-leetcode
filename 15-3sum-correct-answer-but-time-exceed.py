from typing import List


class Solution(object):
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        """
        LeetCode 第 15 題，透過以下測資測試正確，但是時間超時
        [-1,0,1,2,-1,-4]
        [-3,-2,-2,-2,-1,-1,0,1,2,3,4,5,6]
        [2,3,1, 0]
        [-1,-2,-3]
        [-1,1]
        [0]
        [0,0,0]
        [0,0,0,0,0,0]
        [0,-4,-1,-4,-2,-3,2]
        [-14,-10,-1,8,-8,-7,-3,-2,14,10,3,3,-1,-15,6,9,-1,6,-2,-6,-8,-15,8,-3,-14,5,-1,-12,-10,-5,-9,-8,1,-3,-15,0,-3,-11,6,-11,7,-6,7,-9,-6,-10,7,1,11,-10,10,-12,-10,3,-7,-9,-7,7,-14,-9,10,14,-2,-4,-4,-10,3,1,-14,-6,5,8,-4,-11,14,-3,-6,-2,13,13,3,0,-14,8,10,-14,6,11,1,7,-13,-4,6,0,-1,10,-3,-13,-4,-2,-11,8,-8]
        [-7,-1,-13,2,13,2,12,3,-11,3,7,-15,2,-9,-13,-13,11,-10,5,-13,2,-12,0,-8,8,-1,4,10,-13,-5,-6,-4,9,-12,5,8,5,3,-4,9,13,10,10,-8,-14,4,-6,5,10,-15,-1,-3,10,-15,-4,3,-1,-15,-10,-6,-13,-9,5,11,-6,-13,-4,14,-3,8,1,-4,-5,-12,3,-11,7,13,9,2,13,-7,6,0,-15,-13,-11,-8,9,-14,1,11,-7,13,0,-6,-15,11,-6,-2,4,2,9,-15,5,-11,-11,-11,-13,5,7,7,5,-10,-7,6,-7,-11,13,9,-10,-9]

        代表並非期望解法，查閱網路上得知需要使用到 HashMap 因此會再研究正確解法
        """
        # 先排序，由小到大依序尋找
        triplets: List[List[int]] = []
        nums.sort()
        size = len(nums)
        # 如果小於三個值 或 大於等於三筆但第一個值大於 0 或 最後一個值為負值則必定不存在可能結果
        if size < 3 or (size >= 3 and (nums[0] > 0 or nums[size - 1] <= -1)):
            return []
        a = 0
        while(nums[a] <= 0 and a < size - 2):
            b, c = a + 1, a + 2
            # jump 與 found 的作用是用來跳過重複的數值
            jump = b
            found = False
            while((b < size - 1) and (c < size)):
                # 如果尚未遇到不重複的數值，則判斷是否有不重複，有則更新可以跳躍的索引
                if not found:
                    jump = c - 1 if nums[b] != nums[c] else b
                    found = True
                # 若有找到，則把 b 往後移，c 則重新設為的後一位
                if nums[a] + nums[b] + nums[c] == 0:
                    match = [nums[a], nums[b], nums[c]]
                    if match not in triplets:
                        triplets.append(match)
                    b, c = jump + 1, jump + 2
                    found = False
                else:
                    # 不等於 0，如果 c + 1 仍在長度內，表示沒有確認完所有結果
                    # 否則表示此次 a,b 與不同 c 的所有組合找完，調整 b 為下一個值，從新尋找組合
                    if c + 1 < size:
                        c += 1
                    else:
                        b, c = jump + 1, jump + 2
                        found = False
            a += 1
        return triplets


